# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AzureCommunicationChatServiceOperationsMixin:

    async def list_read_receipts(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> List["models.ReadReceipt"]:
        """Gets read receipts for a thread.

        Gets read receipts for a thread.

        :param thread_id: Thread id to get the read receipts for.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of ReadReceipt, or the result of cls(response)
        :rtype: list[~azure.communication.chat.models.ReadReceipt]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.ReadReceipt"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_read_receipts.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[ReadReceipt]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_read_receipts.metadata = {'url': '/chat/threads/{threadId}/readreceipts'}  # type: ignore

    async def send_read_receipt(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        body: Optional["models.PostReadReceiptRequest"] = None,
        **kwargs
    ) -> None:
        """Posts a read receipt event to a thread, on behalf of a user.

        Posts a read receipt event to a thread, on behalf of a user.

        :param thread_id: Id of the thread.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Request payload for sending a read receipt.
        :type body: ~azure.communication.chat.models.PostReadReceiptRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.send_read_receipt.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'PostReadReceiptRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    send_read_receipt.metadata = {'url': '/chat/threads/{threadId}/readreceipts'}  # type: ignore

    async def send_message(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        body: Optional["models.CreateMessageRequest"] = None,
        **kwargs
    ) -> "models.CreateMessageResponse":
        """Sends a message to a thread.

        Sends a message to a thread.

        :param thread_id: The thread id to send the message to.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Details of the message to create.
        :type body: ~azure.communication.chat.models.CreateMessageRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CreateMessageResponse, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.CreateMessageResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CreateMessageResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.send_message.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CreateMessageRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CreateMessageResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    send_message.metadata = {'url': '/chat/threads/{threadId}/messages'}  # type: ignore

    async def list_messages(
        self,
        thread_id: str,
        page_size: Optional[int] = None,
        start_time: Optional[int] = None,
        sync_state: Optional[str] = None,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> "models.ListMessagesResponse":
        """Gets a list of messages from a thread.

        Gets a list of messages from a thread.

        :param thread_id: The thread id of the message.
        :type thread_id: str
        :param page_size: The number of messages being requested.
        :type page_size: int
        :param start_time: The start time where the range query. This is represented by number of
         seconds since epoch time.
        :type start_time: long
        :param sync_state: The continuation token that previous request obtained. This is used for
         paging.
        :type sync_state: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ListMessagesResponse, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.ListMessagesResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ListMessagesResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_messages.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if start_time is not None:
            query_parameters['startTime'] = self._serialize.query("start_time", start_time, 'long')
        if sync_state is not None:
            query_parameters['syncState'] = self._serialize.query("sync_state", sync_state, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ListMessagesResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_messages.metadata = {'url': '/chat/threads/{threadId}/messages'}  # type: ignore

    async def get_message(
        self,
        thread_id: str,
        message_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> "models.Message":
        """Gets a message by id.

        Gets a message by id.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Message, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.Message
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Message"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.get_message.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Message', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}  # type: ignore

    async def update_message(
        self,
        thread_id: str,
        message_id: str,
        correlation_vector: Optional[str] = None,
        body: Optional["models.UpdateMessageRequest"] = None,
        **kwargs
    ) -> None:
        """Updates a message.

        Updates a message.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Details of the request to update the message.
        :type body: ~azure.communication.chat.models.UpdateMessageRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_message.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UpdateMessageRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    update_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}  # type: ignore

    async def delete_message(
        self,
        thread_id: str,
        message_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> None:
        """Deletes a message.

        Deletes a message.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.delete_message.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}  # type: ignore

    async def notify_user_typing(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> None:
        """Posts a typing event to a thread, on behalf of a user.

        Posts a typing event to a thread, on behalf of a user.

        :param thread_id: Id of the thread.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.notify_user_typing.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    notify_user_typing.metadata = {'url': '/chat/threads/{threadId}/typing'}  # type: ignore

    async def list_thread_members(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> List["models.ThreadMember"]:
        """Gets the members of a thread.

        Gets the members of a thread.

        :param thread_id: Thread id to get members for.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of ThreadMember, or the result of cls(response)
        :rtype: list[~azure.communication.chat.models.ThreadMember]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.ThreadMember"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_thread_members.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('[ThreadMember]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_thread_members.metadata = {'url': '/chat/threads/{threadId}/members'}  # type: ignore

    async def add_thread_members(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        body: Optional["models.AddThreadMembersRequest"] = None,
        **kwargs
    ) -> None:
        """Adds thread members to a thread. If members already exist, no change occurs.

        Adds thread members to a thread. If members already exist, no change occurs.

        :param thread_id: Id of the thread to add members to.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Thread members to be added to the thread.
        :type body: ~azure.communication.chat.models.AddThreadMembersRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.add_thread_members.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'AddThreadMembersRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_thread_members.metadata = {'url': '/chat/threads/{threadId}/members'}  # type: ignore

    async def remove_thread_member(
        self,
        thread_id: str,
        member_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> None:
        """Remove a member from a thread.

        Remove a member from a thread.

        :param thread_id: Thread id to remove the member from.
        :type thread_id: str
        :param member_id: Id of the thread member to remove from the thread.
        :type member_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.remove_thread_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'memberId': self._serialize.url("member_id", member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    remove_thread_member.metadata = {'url': '/chat/threads/{threadId}/members/{memberId}'}  # type: ignore

    async def create_thread(
        self,
        correlation_vector: Optional[str] = None,
        body: Optional["models.CreateThreadRequest"] = None,
        **kwargs
    ) -> "models.CreateThreadResponse":
        """Creates a chat thread.

        Creates a chat thread.

        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Request payload for creating a chat thread.
        :type body: ~azure.communication.chat.models.CreateThreadRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CreateThreadResponse, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.CreateThreadResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CreateThreadResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_thread.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CreateThreadRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CreateThreadResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_thread.metadata = {'url': '/chat/threads'}  # type: ignore

    async def list_threads(
        self,
        page_size: Optional[int] = None,
        start_time: Optional[int] = None,
        sync_state: Optional[str] = None,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> "models.ListThreadsResponse":
        """Gets the list of chat threads of a user.

        Gets the list of chat threads of a user.

        :param page_size: The number of threads being requested.
        :type page_size: int
        :param start_time: The start time where the range query. This is represented by number of
         seconds since epoch time.
        :type start_time: long
        :param sync_state: The continuation token that previous request obtained. This is used for
         paging.
        :type sync_state: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ListThreadsResponse, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.ListThreadsResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ListThreadsResponse"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_threads.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if start_time is not None:
            query_parameters['startTime'] = self._serialize.query("start_time", start_time, 'long')
        if sync_state is not None:
            query_parameters['syncState'] = self._serialize.query("sync_state", sync_state, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ListThreadsResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_threads.metadata = {'url': '/chat/threads'}  # type: ignore

    async def update_thread(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        body: Optional["models.UpdateThreadRequest"] = None,
        **kwargs
    ) -> None:
        """Updates a thread's properties.

        Updates a thread's properties.

        :param thread_id: The id of the thread to update.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :param body: Request payload for updating a chat thread.
        :type body: ~azure.communication.chat.models.UpdateThreadRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_thread.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UpdateThreadRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    update_thread.metadata = {'url': '/chat/threads/{threadId}'}  # type: ignore

    async def get_thread(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> "models.Thread":
        """Gets a chat thread.

        Gets a chat thread.

        :param thread_id: Thread id to get.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Thread, or the result of cls(response)
        :rtype: ~azure.communication.chat.models.Thread
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Thread"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.get_thread.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Thread', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_thread.metadata = {'url': '/chat/threads/{threadId}'}  # type: ignore

    async def delete_thread(
        self,
        thread_id: str,
        correlation_vector: Optional[str] = None,
        **kwargs
    ) -> None:
        """Deletes a thread.

        Deletes a thread.

        :param thread_id: Thread id to delete.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not provided a randomly generated
         correlation vector would be returned in the response header "MS-CV".
        :type correlation_vector: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.delete_thread.metadata['url']  # type: ignore
        path_format_arguments = {
            'endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_thread.metadata = {'url': '/chat/threads/{threadId}'}  # type: ignore
