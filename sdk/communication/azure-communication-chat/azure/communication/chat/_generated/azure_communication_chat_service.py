# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import SDKClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class AzureCommunicationChatServiceConfiguration(Configuration):
    """Configuration for AzureCommunicationChatService
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param endpoint: The endpoint of the Azure Communication resource.
    :type endpoint: str
    """

    def __init__(
            self, endpoint):

        if endpoint is None:
            raise ValueError("Parameter 'endpoint' must not be None.")
        base_url = '{endpoint}'

        super(AzureCommunicationChatServiceConfiguration, self).__init__(base_url)

        self.add_user_agent('azurecommunicationchatservice/{}'.format(VERSION))

        self.endpoint = endpoint


class AzureCommunicationChatService(SDKClient):
    """AzureCommunicationChatService

    :ivar config: Configuration for client.
    :vartype config: AzureCommunicationChatServiceConfiguration

    :param endpoint: The endpoint of the Azure Communication resource.
    :type endpoint: str
    """

    def __init__(
            self, endpoint):

        self.config = AzureCommunicationChatServiceConfiguration(endpoint)
        super(AzureCommunicationChatService, self).__init__(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '2020-07-20-preview1'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def list_read_receipts(
            self, thread_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets read receipts for a thread.

        :param thread_id: Thread id to get the read receipts for.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~azure.communication.chat.models.ReadReceipt] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_read_receipts.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ReadReceipt]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_read_receipts.metadata = {'url': '/chat/threads/{threadId}/readreceipts'}

    def send_read_receipt(
            self, thread_id, client_message_id, message_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Posts a read receipt event to a thread, on behalf of a user.

        :param thread_id: Id of the thread.
        :type thread_id: str
        :param client_message_id: The client message Id specified when the
         message was sent.
         This Id is a client-specific Id in a numeric unsigned Int64 format. It
         can be used for client deduping, among other client usages.
        :type client_message_id: str
        :param message_id: Id of the latest message read by current user.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        body = None
        if client_message_id is not None or message_id is not None:
            body = models.PostReadReceiptRequest(client_message_id=client_message_id, message_id=message_id)

        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.send_read_receipt.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'PostReadReceiptRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    send_read_receipt.metadata = {'url': '/chat/threads/{threadId}/readreceipts'}

    def send_message(
            self, thread_id, correlation_vector=None, body=None, custom_headers=None, raw=False, **operation_config):
        """Sends a message to a thread.

        :param thread_id: The thread id to send the message to.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param body: Details of the message to create.
        :type body: ~azure.communication.chat.models.CreateMessageRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CreateMessageResponse or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.CreateMessageResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.send_message.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CreateMessageRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('CreateMessageResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    send_message.metadata = {'url': '/chat/threads/{threadId}/messages'}

    def list_messages(
            self, thread_id, page_size=None, start_time=None, sync_state=None, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets a list of messages from a thread.

        :param thread_id: The thread id of the message.
        :type thread_id: str
        :param page_size: The number of messages being requested.
        :type page_size: int
        :param start_time: The start time where the range query. This is
         represented by number of seconds since epoch time.
        :type start_time: long
        :param sync_state: The continuation token that previous request
         obtained. This is used for paging.
        :type sync_state: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListMessagesResponse or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.ListMessagesResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_messages.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if start_time is not None:
            query_parameters['startTime'] = self._serialize.query("start_time", start_time, 'long')
        if sync_state is not None:
            query_parameters['syncState'] = self._serialize.query("sync_state", sync_state, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListMessagesResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_messages.metadata = {'url': '/chat/threads/{threadId}/messages'}

    def get_message(
            self, thread_id, message_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets a message by id.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Message or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.Message or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.get_message.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Message', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}

    def update_message(
            self, thread_id, message_id, content, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Updates a message.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param content: Chat message content.
        :type content: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        body = None
        if content is not None:
            body = models.UpdateMessageRequest(content=content)

        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.update_message.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UpdateMessageRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}

    def delete_message(
            self, thread_id, message_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Deletes a message.

        :param thread_id: The thread id to which the message was sent.
        :type thread_id: str
        :param message_id: The message id.
        :type message_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.delete_message.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'messageId': self._serialize.url("message_id", message_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_message.metadata = {'url': '/chat/threads/{threadId}/messages/{messageId}'}

    def notify_user_typing(
            self, thread_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Posts a typing event to a thread, on behalf of a user.

        :param thread_id: Id of the thread.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.notify_user_typing.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    notify_user_typing.metadata = {'url': '/chat/threads/{threadId}/typing'}

    def list_thread_members(
            self, thread_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets the members of a thread.

        :param thread_id: Thread id to get members for.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~azure.communication.chat.models.ThreadMember] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_thread_members.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[ThreadMember]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_thread_members.metadata = {'url': '/chat/threads/{threadId}/members'}

    def add_thread_members(
            self, thread_id, members, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Adds thread members to a thread. If members already exist, no change
        occurs.

        :param thread_id: Id of the thread to add members to.
        :type thread_id: str
        :param members: Members to add to a thread.
        :type members: list[~azure.communication.chat.models.ThreadMember]
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        body = None
        if members is not None:
            body = models.AddThreadMembersRequest(members=members)

        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.add_thread_members.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'AddThreadMembersRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    add_thread_members.metadata = {'url': '/chat/threads/{threadId}/members'}

    def remove_thread_member(
            self, thread_id, member_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Remove a member from a thread.

        :param thread_id: Thread id to remove the member from.
        :type thread_id: str
        :param member_id: Id of the thread member to remove from the thread.
        :type member_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.remove_thread_member.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str'),
            'memberId': self._serialize.url("member_id", member_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    remove_thread_member.metadata = {'url': '/chat/threads/{threadId}/members/{memberId}'}

    def create_thread(
            self, topic, members, correlation_vector=None, is_sticky_thread=None, custom_headers=None, raw=False, **operation_config):
        """Creates a chat thread.

        :param topic: The thread topic.
        :type topic: str
        :param members: Members to be added to the thread.
        :type members: list[~azure.communication.chat.models.ThreadMember]
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param is_sticky_thread: Flag if a thread is sticky - sticky thread
         has an immutable member list, members cannot be added or removed.
         Sticky threads are only supported for 1-1 chat, i.e. with only two
         members.
        :type is_sticky_thread: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: CreateThreadResponse or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.CreateThreadResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        body = None
        if topic is not None or is_sticky_thread is not None or members is not None:
            body = models.CreateThreadRequest(topic=topic, is_sticky_thread=is_sticky_thread, members=members)

        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.create_thread.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'CreateThreadRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('CreateThreadResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    create_thread.metadata = {'url': '/chat/threads'}

    def list_threads(
            self, page_size=None, start_time=None, sync_state=None, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets the list of chat threads of a user.

        :param page_size: The number of threads being requested.
        :type page_size: int
        :param start_time: The start time where the range query. This is
         represented by number of seconds since epoch time.
        :type start_time: long
        :param sync_state: The continuation token that previous request
         obtained. This is used for paging.
        :type sync_state: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ListThreadsResponse or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.ListThreadsResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.list_threads.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if page_size is not None:
            query_parameters['pageSize'] = self._serialize.query("page_size", page_size, 'int')
        if start_time is not None:
            query_parameters['startTime'] = self._serialize.query("start_time", start_time, 'long')
        if sync_state is not None:
            query_parameters['syncState'] = self._serialize.query("sync_state", sync_state, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ListThreadsResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_threads.metadata = {'url': '/chat/threads'}

    def update_thread(
            self, thread_id, topic, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Updates a thread's properties.

        :param thread_id: The id of the thread to update.
        :type thread_id: str
        :param topic: Thread topic.
        :type topic: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        body = None
        if topic is not None:
            body = models.UpdateThreadRequest(topic=topic)

        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.update_thread.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct body
        if body is not None:
            body_content = self._serialize.body(body, 'UpdateThreadRequest')
        else:
            body_content = None

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    update_thread.metadata = {'url': '/chat/threads/{threadId}'}

    def get_thread(
            self, thread_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Gets a chat thread.

        :param thread_id: Thread id to get.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Thread or ClientRawResponse if raw=true
        :rtype: ~azure.communication.chat.models.Thread or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.get_thread.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Thread', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get_thread.metadata = {'url': '/chat/threads/{threadId}'}

    def delete_thread(
            self, thread_id, correlation_vector=None, custom_headers=None, raw=False, **operation_config):
        """Deletes a thread.

        :param thread_id: Thread id to delete.
        :type thread_id: str
        :param correlation_vector: Correlation vector, if a value is not
         provided a randomly generated correlation vector would be returned in
         the response header "MS-CV".
        :type correlation_vector: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        api_version = "2020-07-20-preview1"

        # Construct URL
        url = self.delete_thread.metadata['url']
        path_format_arguments = {
            'endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'threadId': self._serialize.url("thread_id", thread_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)
        if correlation_vector is not None:
            header_parameters['MS-CV'] = self._serialize.header("correlation_vector", correlation_vector, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 404]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_thread.metadata = {'url': '/chat/threads/{threadId}'}
